=encoding utf8

=head1 NAME

dibs - Docker Image Build System

=head1 VERSION

C<dibs>'s version can be retrieved with option L</--version>:

   shell$ dibs --version

=head1 USAGE

   dibs [--usage] [--help] [--man] [--version]

   dibs [--alien|-A]
        [--change-dir|-C directory]
        [--config-file|--config|-c filename]
        [--dirty|--dirty-origin-is-ok|-D]
        [--loglevel|-l levelname]
        [--name|-n name]
        [--origin|-O URI]
        [--project-dir|-p directory]
        [--verbose|-v]
        action [action [action...]]

=head1 EXAMPLES

   # A repo like `dibs` itself, there's a dibs.yml file at the root and
   # this is all that's needed for a "development" run from the root dir
   $ dibs

   # Ditto, but changing directory first
   $ dibs -C /path/to/simple/repo

   # The repo itself might not be aware of the whole dibs part, or take
   # care of a few aspects only to minimise burden on developers. In this
   # case the starting point is a project directory
   $ dibs --alien -C /path/to/project/dir

   # Configuration file is named "dibs.yml" by default, but it's possible
   # to keem more of them around
   $ dibs -c alt-dibs.yml

=head1 DESCRIPTION

C<dibs> allows handling the different steps of building software and
packing it as a I<trimmed> Docker image. A gentle introduction to its
goals and to some examples is provided at
L<https://github.com/polettix/dibs>; this manual page will only provide
lower-level details about using the program itself.

C<dibs> uses a I<project directory> as a basecamp for all operations.
C<dibs> can be run in two modes: I<development> (the default one) and
C<alien>. The only difference between the two is the directory layout:
in C<development mode> a subdirectory C<dibs> is created and used as
C<project directory>, while in C<alien mode> the current directory is
used.

C<dibs> allows executing programs inside containers and optionally save
the results as container images. It manages multiple different I<phases>
of execution, allowing e.g. to distinguish a I<build> phase leveraging a
fat image with many tools installed (e.g. a compiler) and a I<bundle>
phase to generate a lean image. The definition of all possible
I<actions> is done through a configuration file called C<dibs.yml>,
located in the project directory's root.

C<dibs> mounts several directories in a container when it runs programs
inside of them. This allows pass information to and from containers in a
systematic way; more info on L</Directories> is available below.

The I<actions> defined in the configuration file can be of different
types:

=over

=item I<from>

this action sets up the stage for running a container, it's the
equivalent of the C<FROM> directive in the Dockerfile

=item I<stroke>

this action executes a program inside a container

=item I<frame>

this action saves a container as an image

=item I<sketch>

groups multiple actions in a sequence

=back

=head2 Anatomy of a Run

In this section, the following layout is assumed:

    project/
      cache/
      dibs.yml
      env/
         sample-file.json
      src/
         app.pl
         cpanfile

The current working directory is assumed to be C<project>. This is the
typical layout for L</Alien mode>, where the project directory tracks a
(potentially) remote project that is unaware of C<dibs> (or not directly
involved).

When C<dibs> is run:

    $ dibs --alien

the following happens:

=over

=item *

command-line options are parsed. In this case, the C<--alien> option
sets C<dibs> up to expect the directory layout above

=item *

the configuration file C<dibs.yml> is loaded and parsed lazily (i.e. its
parts are expanded only when strictly needed).

=item *

the actions to be executed are collected. In this case there is no
explicit indication in the command line, so an action named C<default>
is looked for in the loaded configuration

=item *

each action is executed in the order specified.  Top level actions are
I<sketches> that start from a I<from> action, usually followed by
some I<strokes> and optionally terminated with a I<frame> that saves the
image. In particular, for I<stroke> actions:

=over

=item *

a directory C<envile> is created and several files are saved inside,
representing key-value pairs

=item *

a container is run, with most of the directories in the project mounted
inside (read-only or read-write, depending on the directory).

=back

=back

Programs executed in a stroke can be local or remote (e.g. in a `git`
repository); to help locate the right artifacts, C<dibs> introduces the
concept of I<pack> (also called C<dibspack>). In some contexts, packs
(especially remote ones) can also hold additional configurations.

Within a container, many data are available in the form of so-called
I<enviles>. An envile is just a variable passed through a file in the
L</envile> directory, much like an environment variable.

=head2 Directories

There are several directories of interest in C<dibs>, explained in the
following sections; unless otherwise noted, they are all sub-directories
of the I<project directory>. The generic complete layout is as follows
(directories that are also mounted in the container and the envile that
holds their position is also indicated)

    directory in host | envile in container | notes
    ------------------+---------------------+----------------------
    project/          |                     |
      auto/           |                     |
         host-only/   |                     |
         open/        | DIBS_DIR_AUTOPACK   |
      cache/          | DIBS_DIR_CACHE      |
      env/            | DIBS_DIR_ENV        |
      envile/         | DIBS_DIR_ENVILE     | container working dir
      pack/           | DIBS_DIR_PACK       |
      src/            | DIBS_DIR_SRC        |


=head3 C<auto>

This directory is used for retrieving and locally store remote or
dynamic packs. It has two sub-directories:

=over

=item C<host-only>

this directory contains packs whose goal is only to carry additional
configurations, which are of interest only in the host and not inside
the containers. This directory is not mounted in the container.

=item C<open>

this directory contains packs that are of interest inside the container.
It is mounted read-only and its location is stored in envile
C<DIBS_DIR_AUTOPACK>.

=back

This directory is managed by C<dibs> automatically and should not be
used otherwise.

=head3 C<cache>

This directory is meant as a repository for easing communication across
different phases of execution (i.e. potentially across independent
containers).

It is mounted read-write and its management is completely under user's
control; its position is saved in envile C<DIBS_DIR_CACHE>.

=head3 C<env>

This directory is meant to hold whatever the user sees fit. It is
mounted read-only inside the container, its position stored in envile
C<DIBS_DIR_ENV>.

=head3 C<envile>

This directory holds files representing environment variables: filenames
are the variable's names, file contents are the associated values. In
addition, a file C<export-enviles.sh> is also saved, to help loading the
variables in a shell script.

The choice to save variables as files stems from the fact that
environment variables are saved in a container's layer permanently,
which can be undesired for some values (e.g. passwords, or transient
values).

This directory is generated and managed by C<dibs> and should not be
used otherwise (it is wiped out when needed). To save specific data, the
C<env> directory should be used instead.

This directory is mounted read-only and is also set as the initial
working directory in each container that is started, so that e.g. the
location of all other directories can be found easily; in any case, its
position is also stored in envile C<DIBS_DIR_ENVILE>.

=head3 C<pack>

This directory aims at containing programs to be executed inside the
containers, or their associated artifacts (e.g. other programs).

Remote programs that are fetched e.g. via `git` are not placed here, but
inside L</auto> instead; this directory is meant for storing programs
that are specific to the project.

The directory is mounted read-only, its position available in envile
C<DIBS_DIR_PACK>.

=head3 C<src>

This directory is assumed to carry the project's source code. It can be
populated externally or automatically by C<dibs>. It is mounted
read-write and its position is available in envile C<DIBS_DIR_SRC>.

In C<development mode> the directory is populated automatically based on
the code's local git setup (i.e. the code MUST be tracked via `git`); in
C<alien mode> it might be assumed to be populated externally, or
populated automatically using the L</origin> directive.

=head2 Modes Of Operation

There are two main modes of operations, explained in the following
sections.

=head3 Alien mode

This mode is useful when a remote source project is tracked. The source
project might even be unaware of C<dibs> completely.

The typical layout is the following:

    project-directory/
      auto/
         host-only/
         open/
      cache/
      dibs.yml
      env/
      envile/
      pack/
      src/

In alien mode, the working directory (the current one, or the one after
changing it via L</--change-dir>) is coincident with the project
directory; additionally, no automatic origin is set, so the C<src>
sub-directory is either otherwise-populated (e.g. directly edited,
independently expanded from a tar file, etc.) or the real origin has to
be set explicitly.

=head3 Developer mode

This mode is useful for developers that want to leverage C<dibs>
directly in their code layout. This is also the default mode of
operation (in lack of C<--alien> or equivalent options).

In developer mode, the typical layout is as follows:

    code-source-root/
      .git
      ah-some-code.pl
      ah-other-code.c
      dibs.yml
      dibs/
         auto/
            host-only/
            open/
         cache/
         env/
         envile/
         pack/
         src/

In this case, the source is edited in the top tree (C<code-source-root>
in the example) and then transferred inside C<src> at the beginning. As
a matter of fact, the code is I<checked out>, which implies that:

=over

=item *

the base source directory MUST be tracked with `git`, and

=item *

the changed code MUST be committed to be used.

=back

The above behaviour is obtained by automatically setting the I<origin>
(L</--origin>) to C<.>, assuming that the C<dibs> command is run from
the code's root directory.

In case the `git` repository is not in a clean state, the C<dibs>
command will complain. This will prevent running it e.g. in case the
user forgets to commit the work before running C<dibs>. It is possible
to override this safecheck using option L</--dirty>, although this is
probably only useful only when modifying the C<dibs.yml> file itself (it
is always taken from the original directory if present).

=head1 OPTIONS

C<dibs> supports some command line options. Some of them are I<meta>, in
the sense that their goal is to provide information about C<dibs> itself;
other options are actually used by C<dibs> to do its intended job.

=head2 Meta-Options

The following I<meta-options> allow getting more info about C<dibs>
itself:

=over

=item --help

print a somewhat more verbose help, showing usage, this description of
the options and some examples from the synopsis.

=item --man

print out the full documentation for the script.

=item --usage

print a concise usage line and exit.

=item --version

print the version of the program.

=back


=head2 Real Options

The following options are supported by C<dibs> as part of its mission. The
are reported both as environment variables (all uppercase, no leading
dash) and as command line options; when both are present, the command line
option takes precedence.

The values cannot in general be overridden from configurations coming from
the configuration file; any exception is explicitly acknowledged.

I<Straight> command line arguments represent actions to be executed in
the specific run (by default, an action named C<default> is executed):

   $ dibs first second third fourth last

It defaults to whatever is found inside the C<dibs.yml> configuration
file. The example above leads to the following list of steps:

   - first
   - second
   - third
   - fourth
   - last

=over

=item --alien

=item -A

=item DIBS_ALIEN

   $dibs --alien

set the L</Alien mode> directory layout.

=item --change-dir

=item -C

=item DIBS_CHANGE_DIR

   $ dibs --change-dir /path/to/whatever

change directory as soon as possible and continue operations from there.
This allows e.g. having ugly wrappers to change directory before running
C<dibs> itself, which is useful especially when using the Docker image for
C<dibs>.

Optional parameters, default is to operate from current directory.

This is considered only before loading a configuration file, so any
setting inside the configuration file is ignored.

=item --config-file

=item --config

=item -c

=item DIBS_CONFIG_FILE

   $ dibs --config-file dibs-alternative.yml

set name of the configuration file. Defaults to C<dibs.yml>.

In L</Alien mode>, a relative path is referred to the project directory.
In L</Developer mode>, though, a relative path is first looked for
starting from the current directory, then from the project directory.
This allows keeping the C<dibs.yml> file in the code's root directory.

This is considered only before loading a configuration file, so any
setting inside the configuration file is ignored.

=item --dirty

=item -D

=item DIBS_DIRTY

   $ dibs --dirty

allow for a dirty origin repository. When an origin repository is set
for cloning/checking out L</src>, C<dibs> checks its state (if local)
and refuses to proceed if it is dirty (i.e. with uncommitted changes
and/or untracked files); this is useful in L</Developer mode> to prevent
running C<dibs> without recent changes.

It is generally advised to avoid this option. A notable exception is
when changing the C<dibs.yml> file itself in L</Developer mode>, because
the one in the main directory is taken directly.

=item --loglevel

=item -l

=item DIBS_LOGLEVEL

   $ dibs --loglevel INFO

set the log level, which can be any of C<emergency>, C<alert>, C<fatal>,
C<error>, C<warn>, C<notice>, C<info>, C<debug>, C<trace> and a few
variations (C<dibs> relies upon L<Log::Any>).

=item --name

=item -n

=item DIBS_NAME

   $ dibs --name whatever

set the I<name> for temporary images that are saved along during
execution (and later disposed of). This option can also be set inside
the configuration file.

=item --origin

=item -O

=item DIBS_ORIGIN

   $ dibs -O /path/to/origin.git

set a I<Git origin> from where C<src> will be cloned.

The clone is performed in the I<host context>, before the containers are
invoked. It is always done at the beginning and only once per invocation,
even in steps that technically do not rely on it (C<dibs> has no way to
tell).

The origin can be set inside the C<dibs.yml> file.

In L</Developer mode>, this option is set automatically to C<.>.

In L</Alien mode>, this option can also be set inside the configuration
file.

=item --project-dir

=item -p

=item DIBS_PROJECT_DIR

   $ dibs --project-dir directory

set the base directory of the project.

By default (i.e. L</--alien> is not set) it is the C<dibs> sub-directory
of the current directory (after L</--change-dir>).

In L</Alien mode> it defaults to the current directory (after
L</--change-dir>).

This option is computed before loading the configuration file and cannot
be overridden even when missing from environment and/or command line.

=item --verbose

=item -v

=item DIBS_VERBOSE

   $ dibs --verbose

Enable additional information during execution. This option can also be
set in the configuration file.

=back


=head1 CONFIGURATION

Invocation of C<dibs> is explained in section L</OPTIONS>, which includes
command-line options and environment variables.

The core of the configuration for C<dibs> comes from the C<dibs.yml>
configuration file (but see L<--config-file>). This file has
a I<free-form>, in that only a few keys are meaningful to C<dibs> and the
rest is up to the writer (e.g. to concentrate other configurations that
can be of help for other tools).

An example skeleton of a configuration is the following, defining a
couple of packs (C<foo> and C<bar>), three stroke actions (C<brof>,
C<galook>, and C<omg>) and a C<default> sketch (which is also executed
by default, as hinted by its name).

    ----
    name: ...
    packs:
      foo: ...
      bar: ...
    actions:
      brof:
         pack: foo
         ...
      galook:
         pack: bar
         ...
      omg:
         pack: foo
         ...
      default:
         - from: 'alpine:3.6'
         - brof
         - galook
         - omg
         - tags: ...

Higher level keys are C<actions>, C<logger>, C<name>, C<origin>,
C<packs>, and C<variables>, in addition to C<env> and C<envile> because
the top-level object is one of the L</Environment Carriers>. They are
explained in depth in the following sections.

=head2 Environment Carriers

Some elements in the configuration (notably the top-level object, as
well as L</Action sketch> and L</Action stroke>) are so-called
I<environment carriers>, i.e. support the following two keys:

=over

=item key C<env>

either an Associative array with key-value pairs, or an Array of such
Associative arrays (to be merged in order). The keys are used as
environment variables, set to the associated values (undefined variables
are ignored).

Care must be taken when setting environment variables: Docker makes
those variables persist in the container images, so any value set here
will stick to the final image. If this is not desirable, it's better to
set a corresponding C<envile>.

=item key C<envile>

either an Associative array with key-value pairs, or an Array of such
Associative arrays (to be merged in order). The keys are used as file
names in the L</envile> directory, with contents set to the associated
values (undefined variables are ignored).

=back

Application of those keys is from the outside to the inside. So, for
example, if the top-level configuration object defines an environment
variable C<WHATEVER>, its value will be used in all sketches and
strokes, unless it is overridden by a sketch (which will apply to all
its actions) or by a stroke (which will apply to its execution).

Example:

    env:
      FOO: BAR
    actions:
      some-stroke:
         env:
            FOO: BAZ
         type: stroke
         ...
      another-stroke:
         type: stroke
         ...
      some-sketch:
         env:
            FOO: WHATEVER
         actions:
            - some-stroke
            - another-stroke
      another-sketch
         actions:
            - some-stroke
            - another-stroke

When C<some-sketch> is executed, action C<some-stroke> gets C<FOO> set
to C<BAZ> (because it's set directly in the stroke itself), while action
C<another-stroke> gets value C<WHATEVER> (because it does not set it by
itself, and inherits it from the sketch).

When C<another-sketch> is executed, C<some-stroke> still gets C<FOO> set
to C<BAZ> (same reason as above), but C<another-stroke> gets the
top-level value C<BAR>.

The same applies to enviles of course.

=head2 Configuration C<actions>

Associative array, containing definitions of actions. There are several
different types of actions, as explained in each following subsection.

All actions take the I<canonical form> of an associative array
themselves. In some cases they may be specified in a simplified form,
e.g. a string or an array. The I<canonical form> always has the same
shape for all actions, i.e. an associative array that allows the
following keys:

=over

=item C<extends>

a reference to another action, or an Array of such references, from
which to inherit traits. More details in L</Inheritance>.

=item C<name>

the name of the action, used in the output log;

=item C<output_char>

the character used to mark the specific action in the output log. The
default value depends on the type of action, but it's possible to
override it. For example, an action of type C<frame> named C<whatever>
would normally appear as follows:

    +++++> frame whatever

but with this char set to C<#> it would appear like so:

    #####> frame whatever

=item C<type>

sets the type of the action and the additional key-value pairs that are
used from the definition. Explicit specification of the action type is
seldom needed (always for custom ones, though), because the type is
usually implied from the presence of other type-specific keys, as
explained below.

=back

In the following sub-sections dedicated to specific action types, only
key-value pairs specific to the respective types will be explained.

=head3 Textual representations

Most actions (with the notable exception of C<sketch>) allow a simpler,
string-based form with the following format:

    TYPE:PARAMETER

where C<TYPE> sets the type and C<PARAMETER> is used by the specific
type to populate its specific parameters. The C<TYPE> might be a class
name itself, so the following:

    My::Class:some,additional,data

sets C<TYPE> to C<My::Class> and C<PARAMETER> to
C<some,additional,data>.

=head3 External references

It is possible to specify an action as a reference to another action.
For example:

    actions:
      foo: ...
      bar: foo

makes C<bar> resolve to whatever action C<foo> is. This is in particular
useful to refer to definitions in external configurations files, using
the C<< <NAME>@<PACK> >> syntax:

    packs:
      baz: ...
    actions:
      bar: foo@baz

=head3 Inheritance

To improve space for factoring configurations and avoid repetitions,
actions support a basic form of inheritance, triggered by key
C<extends>.

An action that I<extends> another one inherits all the parent's
configurations, with the possibility of overriding them (all or in
part). The overriding is always total, i.e. the substitution is
complete.

The following example helps clarifying the mechanism:

    actions:
      foo:
         pack:
            run: |
               #!/bin/sh
               exec >&2
               whoami
               printf 'Howdy, all!\n'
               while [ "$#" -gt 0 ] ; do
                  printf 'argument: <%s>\n' "$1"
                  shift
               done
         user: ubuntu
         commit:
            entrypoint: []
            cmd: ['/bin/sh', '-l']
         args: ['Hello', 'World!']
      bar:
         extends: foo
         args: [1, 2, 3]
      baz:
         extends: foo
         args: ['A', 'B', 'C']

Key C<foo> defines a stroke, whose definition is inherited by both
C<bar> and C<baz>. These two strokes, though, set a different C<args>
value, which means that the above definition is equivalent to the
following one:

    actions:
      foo:
         pack:
            run: |
               #!/bin/sh
               exec >&2
               whoami
               printf 'Howdy, all!\n'
               while [ "$#" -gt 0 ] ; do
                  printf 'argument: <%s>\n' "$1"
                  shift
               done
         user: ubuntu
         commit:
            entrypoint: []
            cmd: ['/bin/sh', '-l']
         args: ['Hello', 'World!']
      bar:
         pack: # ------------------------------------------
            run: |                                    #  ^
               #!/bin/sh                              #  |
               exec >&2                               #  |
               whoami                                 #  |
               printf 'Howdy, all!\n'                 #  |
               while [ "$#" -gt 0 ] ; do              # same as foo
                  printf 'argument: <%s>\n' "$1"      #  |
                  shift                               #  |
               done                                   #  |
         user: ubuntu                                 #  |
         commit:                                      #  |
            entrypoint: []                            #  v
            cmd: ['/bin/sh', '-l'] # ----------------------
         args: [1, 2, 3]
      baz:
         pack: # ------------------------------------------
            run: |                                    #  ^
               #!/bin/sh                              #  |
               exec >&2                               #  |
               whoami                                 #  |
               printf 'Howdy, all!\n'                 #  |
               while [ "$#" -gt 0 ] ; do              # same as foo
                  printf 'argument: <%s>\n' "$1"      #  |
                  shift                               #  |
               done                                   #  |
         user: ubuntu                                 #  |
         commit:                                      #  |
            entrypoint: []                            #  v
            cmd: ['/bin/sh', '-l'] # ----------------------
         args: ['A', 'B', 'C']

but the first one is much more concise and easier to maintain.

=head3 Action C<frame>

This action allows saving a container as an image, so that it can be
later used and/or distributed.

The type is C<frame>. Specific keys are the following:

=over

=item C<image_name>

optional, sets the name of the image, to which all tags will be
associated (if possible).

=item C<tags>

a string with a single tag, or an array of strings.

Each string can be a complete image name by itself (if it contains the
C<:> character, like C<whatever:1.0>) or a tag to be applied to
C<image_name>.

There are two special values that trigger a different behaviour:

=over

=item special value: C<< * >>

uses the temporary tag used for operations (generated dynamically at
each run). For example, if the temporary image name is:

    my-project:20190103-072001-3820

and the C<image_name> is set to C<whatever>, this would generate image:

    whatever:20190103-072001-3820

=item special value: C<< :default: >>

preserves the temporary image name and tag used for operations
(generated according to L</name>).

=back

=back

The short form allows leaving out C<type> if either of C<image_name> or
C<tags> is present.

Example:

    some-action:
      image_name: whatever
      tags:
        - 1.0
        - latest
        - foobar:5.4

is parsed as type C<frame> (contains both fields), generating image tags
C<whatever:1.0>, C<whatever:latest> and C<foobar:5.4>.

In the simplified, string form, the C<PARAMETER> is interpreted as a
single tag, e.g.:

    simple-frame: frame:whatever:latest

is normalized as follows:

    simple-frame:
      type: frame
      tags:
         - whatever:latest

=head3 Action C<from>

This action sets the starting image for a sequence of additional
actions. It's the equivalent of a C<FROM> directive in a Dockerfile. It
is needed before any L</Action stroke> or L</Action frame> can be
executed, because it prepares the starting image that will be used by
those actions to perform operations and build additional layers on top
of it.

The type is C<from>. Specific keys are the following:

=over

=item C<from>

sets the specification for a Docker image to start from. Anything good
for Docker is also good here.

=back

The mere presence of C<from> triggers automatic recognition of type
C<from>, so this:

    some-action:
      from: alpine:3.6

is normalized as this:

    some-action:
      type: from
      from: alpine:3.6

In the string form, the C<PARAMETER> is interpreted as the value for
C<from>, so this works as a simplification of the above example:

    some-action: 'from:alpine:3.6'

=head3 Action C<log>

This action prints out an optional log message and dumps the
configuration (if so requested). It can be useful for debugging or
otherwise messaging purposes (e.g. provide instructions).

The type is C<log>. Specific keys are the following:

=over

=item C<dump>

boolean, sets whether to dump the configuration or not. Defaults to a
false value.

=item C<message>

optional message to be printed out.

=back

Presence of either key automatically sets the type to C<log>.

In the string form specification, the C<PARAMETER> is used to set the
C<message> to be printed, so this:

    a-log: 'log:whatever you can think of'

is normalized in:

    a-log:
      type: log
      message: 'whatever you can think of'

=head3 Action C<sketch>

This is a I<meta>-actions actually, acting as a container for other
actions. It can be useful e.g. to group sequences of actions that might
be repeated through several different targets, or to define whole
targets themselves.

The type is C<sketch>. Specific keys are the following:

=over

=item C<actions>

an Array of actions to be executed, in the specific order. Actions can
be specified as reference to other actions in L</Configuration actions>,
or to other external actions (according to L</External references>) or
as I<inline> actions, following the same rules explained in
L</Configuration actions>. Example:

    actions:
      foo: ...
      bar: ...
      my-sketch:
         actions:
            - from: 'alpine:3.6'     # "inline" action, from
            - foo                    # reference to "foo" above
            - bar                    # reference to "bar" above
            - 'frame:whatever:1.0'   # "inline" action, frame

=item C<env>

this key is supported as explained in L</Environment Carriers>.

=item C<envile>

this key is supported as explained in L</Environment Carriers>.

=back

Appearance of the C<actions> key triggers automatic recognition as a
C<sketch>, so for example:

    my-action:
      actions: ['this', 'that']

is normalized as:

    my-action:
      type: sketch
      actions: ['this', 'that']

A sketch might also appear as an Array (instead of an Associative
array). In this case, the contents of the Array are moved into the
C<actions> key explained above, and all other values take their
defaults. This means that the following:

    my-action: ['this', 'that']

is normalized as in the example above.

This type does not allow a simplified string form.


=head3 Action C<stroke>

This action allows executing an operation inside the container, adding a
layer on top of the previous action (either
another L<stroke|/Action stroke>, or an L<action from|/Action from>). It
can be seens as an evolved C<RUN> directive in a Dockerfile.

The type is C<stroke>. Specific keys are the following:

=over

=item C<args>

a single value, or an array of values, that are passed to the program
executed inside the container. Optional, by default nothing is passed.
Useful to reuse the same operation in different contexts.

It is possible to include dynamic data in the arguments list (beyond the
capabilities of the variables) by including an object instead of a plain
value. Supported alternatives are in the following examples:

   args:
      - plain-value
      - { 'path_src': 'foo' }    # sub-path "foo" inside the src directory
      - { 'type': 'path', 'src': 'bar' } # similar, with "bar"
      - { 'type': 'sketch_id' }   # the identifier of the sketch
      - { 'type': 'sketch_name' } # you guess



=item C<commit>

this optional key points to an Associative array that helps setting
additional features in the layer produced by the stroke. It supports the
following keys:

=over

=item C<author>

the author of the layer

=item C<cmd>

a default command to execute (subject to the entrypoint though),
equivalent to the C<CMD> directive in a Dockerfile;

=item C<entrypoint>

equivalent to the C<ENTRYPOINT> directive in a Dockerfile;

=item C<label>

equivalent to the C<LABEL> directive in a Dockerfile;

=item C<message>

sets a message in the metadata;

=item C<user>

sets the default user to be used when running a container based on this
image;

=item C<workdir>

sets the working directory when launching the container from the image.

=back

All values that are present are associated to the layer and might be
overwritten by other layers on top. In particular, Dibs itself makes use
of C<cmd>, C<entrypoint> and C<workdir>, so to set those ones in an
image they have to be set in the topmost layer (i.e. the last stroke
that is executed).

=item C<env>

this key is supported as explained in L</Environment Carriers>.

=item C<envile>

this key is supported as explained in L</Environment Carriers>.

=item C<pack>

either a reference to a definition in the L</Configuration packs>, or an
inline definition of a pack (according to the rules in L</Configuration
packs>). The reference might be a remote one, in the form C<<
<NAME>@<PACK> >>, where C<PACK> is a reference to a definition in
L</Configuration packs>.

=item C<path>

Some packs (especially remote packs specified as `git` repositories) are
actually collections of items that map onto directories instead of
single files. In this case, the C<path> parameter allows selecting a
file inside those directories, so it is always referred relative to the
specifica pack's directory.

=item C<user>

the user with which the container should be run, defaults to C<root>.
Most software is best compiled as a regular, restricted user because it
might provide special features when compiled as C<root>, so setting this
to the least privileged profile required can help improving the security
of the final image.

=back

Examples:

=over

=item *

the following example uses an inline pack definition of a shell script:

    my-stroke:
      pack:
         run: |
            #!/bin/sh
            printf >&2 'Howdy, all!\n'

=item *

in the following example, a pack is defined and then used in two
strokes:

    packs:
      sample-pack:
         run: |
            #!/bin/sh
            exec >&2
            whoami
            printf 'Howdy, all!\n'
            while [ "$#" -gt 0 ] ; do
               printf 'argument: <%s>\n' "$1"
               shift
            done
    actions:
      first-stroke:
         pack: sample-pack
         args: [1, 2, 3]
      second-stroke:
         pack: sample-pack
         args: ['A', 'B', 'C']
         user: kermit

=back


=head3 Other actions

The actions described above are those shipped with C<dibs> by default.
It's possible to extend C<dibs> with additional actions though, by
implementing them as Perl classes (e.g. C<My::Class>) and then using
them as follows:

    actions:
      my-action: # any name will do
         type: My::Class
         ... # additional parameters for the custom type
      # ...
      some-sketch:
         - from: 'alpine:3.6'
         - my-action

Details for implementing custom actions are provided in L</Custom
Actions>.

=head2 Configuration C<logger>

Dibs relies upon L<Log::Any> for logging. The C<logger> section allows
setting the parameters for L<Log::Any::Adapter>, e.g.:

    logger: ['Stderr', 'log_level', 'info']

is translated into the corresponding setting for L<Log::Any::Adapter>
(in this case, setting the logger to print to standard error, with a
severity of at least C<info>).

=head2 Configuration C<name>

This C<name> is used as the name of the temporary image across actions.
L</Action from> and L</Action stroke> generate as output such an
image, that is normally deleted at the end.

At each run, C<dibs> also generates a uniquish tag to generate the full
image name, in the form of C<< <DATE>-<TIME>-<PID> >> (e.g.
C<20190103-072001-3820>), so if C<name> is set to C<whatever>, the image
name might be something like C<whatever:20190103-072001-3820>.

It is possible to preserve this temporary name as a permanent image
using tag C<:default:>, more information in L</Action frame>.

=head2 Configuration C<origin>

In most cases, a Dibs project is about packing some code into a
container image. This option allows setting a `git` origin for
retrieving the code for packing.

The format is a string that is suitable for retrieval via `git`, so most
URI types should work. Additionally, when a I<fragment> is specified
after a hash character C<#>, what follows is intepreted as a reference
to be checked out.

Examples:

=over

=item *

    origin: http://example.com/a/project.git

retrieves C<http://example.com/a/project.git> in L</src>, using the
default branch set (usually C<master>)

=item *

    origin: http://example.com/a/project.git#v72

retrieves the same remote `git` repository, but checks out C<v72> (which
might be a branch or a tag, i.e. whatever `git` is happy to use for
checking out).

=back

=head2 Configuration C<packs>

Associative array containing definitions for (dibs)packs. A pack is a
fancy name to define a locator for some content.

There are several pack types defined in Dibs, with the possibility to
add more (according to L</Custom Pack Implementation>); the different
types are explained in the subsections to follow.

At the highest level, packs are distinguished between I<static> and
I<dynamic>. Static ones are those that are somehow already available to
C<dibs>, because they are located in some specific place (e.g. within
the C<src> subtree, or directly inside the container).  Dynamic packs,
on the other hand, need to be gathered before being used.  In this case,
C<dibs> first gets the pack contents and stores it in one of two
possible positions, then treats them like static ones (after they are
available, that is).

Packs mainly serve two purposes: providing programs/artifacts for
execution inside the container, and providing additional configuration
sources. In the latter case, the material must be accessible (only) from
the host, so container-only items are excluded.

Dynamic packs are always saved inside the C<auto> sub-tree. In case of
packs that can be accessed from the container, they are saved inside
C<auto/open>, otherwise in C<auto/host-only>.

Much like L<actions|/Configuration actions>, packs have a canonical form
of an Associative array with a basic key C<type>, that can be one of the
basic types or a custom factory class (details in L</Custom Pack
Implementation>. Additionally, types generally also support a
simplified, string-based configuration that is parsed and normalized
into the canonical form.

=head3 Pack C<git>

This pack type specifies a C<git> repository, which can be accessed
through any URI that can be used by C<git>.

The type is C<git>. The following additional keys are supported:

=over

=item C<origin>

a URI suitable for C<git> cloning. If a I<fragment> is present (i.e. a
part after a dash character C<#>), it is used as a ref-ish for checking
out a specific commit; this is optional and alternative to using C<ref>
below.

=item C<ref>

a ref-ish string, which can be a branch name, a tag or a digest, i.e.
whatever C<git> deems sufficient for checking out. This parameter is
optional and cannot appear if C<origin> also has a I<fragment>.

=back

Just specifying a git remote in a string form is sufficient for
auto-detection of this pack type.

Example:

    packs:
      basic:
         type: git
         origin: https://github.com/polettix/dibspack-basic.git

Packs of type `git` are always directories, so their usage (e.g. in a
stroke) needs the specification of a C<path> referred to the base
checkout directory of the remote repository.

=head3 Pack C<immediate>

This pack allows specifying an artifact/program directly in the
configuration file, most probably in the form of a shell script.

The type is C<immediate>. There is support for two additional keys
C<run> and C<program>, which are aliases and represent the program to be
executed. Presence of either key auto-detects this type.

Example:

    packs:
      some-operation:
         run: |
            #!/bin/sh
            printf >&2 'Hello, world!\n'

is normalized into:

    packs:
      some-operation:
         run: |
            #!/bin/sh
            printf >&2 'Hello, world!\n'
         type: immediate


=head3 Pack C<inside>

This pack type allows specifing a path inside the container, e.g.
because it is known that the specific program is already available from
the base image.

The type is C<inside>. The following additional keys are supported:

=over

=item C<base>

a base path, which might be the full path or a path to the directory.

=item C<path>

a path that is referred to C<base> or by itself (if C<base> is missing).

=back

At least one of C<base> or C<path> must be specified. The global path is
computed as follows:

=over

=item *

if both C<base> and C<path> are present, C<path> is considered relative
to C<base>;

=item *

otherwise the one between C<base> and C<path> that is defined is
considered.

=back

The textual shortcut as format C<< inside:<PATH> >>, where C<PATH> sets
C<base>. This allows specifying a directory in the container as a pack,
and then use C<path> from a stroke.

=head3 Pack C<project>

This type specifies a path relative to the C<pack> directory in the
project directory.

The type is C<project>. For every other aspect it is equal to L</Pack
inside> described above.

=head3 Pack C<src>

This type specifies a path relative to the C<src> directory in the
project directory.

The type is C<src>. For every other aspect it is equal to L</Pack
inside> described above.


=head2 Configuration C<variables>

Array containing variables (or constants) that can be reused across the
file.

It is a good place to put YAML anchors to be referenced with YAML
aliases in other parts of the configuration, in order to avoid
repetitions. For example:

    variables:
      - &base_image  'alpine:3.6'
      - &build_image 'builder:1.0'

There is more to it anyway:

=over

=item *

if the item is an array reference, it will be interpreted as a I<function
call> where the first item in the array is the function to call and the
rest of items are passed as arguments (after having been recursively
expanded (if the item is an array or hash reference itself);

=item *

if the item is a hash reference, each I<value> that is an array reference
is expanded (recursively) like described above for array references.

=back

B<NOTE>: I<recursively> above refers to array references only, i.e. the
recursion is not applied to sub-hashes (and to arrays inside sub-hashes).

Supported functions are as follows:

=over

=item * C<array_flatten>

flatten an array reference, if you ever define a function that returns an
array reference that needs such expansion.

=item * C<array_wrap>

generate an array reference. This is useful if you actually want to define
a variable with a refernce to an array or hash, without any further
expansion (otherwise, it would be subject to the variable expansion
described above, because it is recursive). Example:

    variables:
        # this results in array ['whatever', 2, 3]
      - &arrayref  ['array_wrap', 'whatever', 2, 3]

        # this results in hash {what: ['ever', 'you', 'do']}
      - &hashref   {what: ['array_wrap', 'ever', 'you', 'do']}

=item * C<dibs_date>

the value of C<DIBS_DATE> as generated automatically at each run.

=item * C<dibs_epoch>

the value of C<DIBS_EPOCH> as recorded automatically at each run.

=item * C<dibs_id>

get the identifier for the specific run of C<dibs>. You might want to pass
this explicitly to a sketch, or use it to compose a bigger identifier. Or
generate an image name, why not!

=item * C<dibs_time>

the value of C<DIBS_TIME> as generated automatically at each run.

=item * C<empty_default>

return first value if not empty, the second (default) value otherwise.
Example:

    variables:
      - &version ['empty_default', ['env', 'VERSION'], '1.0']

=item * C<env>

get environment variable(s). Example:

    variables:
      - &version ['env', 'VERSION']
      - &fullname ['join', '-', ['env', 'NAME', 'SURNAME']]

=item * C<epoch>

just Perl's C<time>.

=item * C<get_runvar>

get specific variable, generated at runtime. There are a handful and they
are all accessible through specific functions, so you shouldn't need this
anyway.

=item * C<get_var>

variables in C<variables> that are defined as key-value pairs also end up
as I<named variables> that you can then recall later. Why you would want
to do this is a little beyond this documentation at the moment, stay
tuned!

=item * C<gmtime>

Perl's C<gmtime>, invoked with an optional additional parameter or, in
lack thereof, with L</dibs_epoch> above.

=item * C<join>

behaves like the Perl counterpart, taking the first parameter as separator
and joining the rest with it. In the example above, the first is expanded
as C<0.1.1> and the second one as C<0.1>.

=item * C<localtime>

expand to Perl's C<localtime>. You can optionally pass an epoch, or rely
on L</dibs_epoch>. Example:

    variables:
      - &dibs_epoch_localtime ['localtime']
      - &specific_localtime   ['localtime', 90138600]

=item * C<passthrough>

as the name says, just pass the rest of the array through to the upper
layer. Still looking for the right example...

=item * C<path>

expand to a path in one of the L</Directories>. Examples:

   variables:
      - &prereqs_dir  [path, src, prerequisites]
      - &cache_target [path, cache, foo, bar]

=item * C<set_runvar>

override a run variable, e.g. C<DIBS_ID> or C<DIBS_EPOCH>, should you need
to do this. This is the counterpart to C</get_runvar> above.

=item * C<set_var>

explicitly set a named variable. This is the counterpart to L</get_var>
above.

=item * C<set_vars>

set multiple named variables from one of possibly multiple hashes. Example:

    # use environment variable SELECTOR to get one of the possible
    # groups of definitions. This env variable is assumed to take values
    # like 'first_group', 'second_group' and so on.
    variables:
      -
         - set_vars
         - [env, SELECTOR] # use SELECTOR env variable as... selector
         - first_group
         - foo: foo
           bar: galook
         - second_group
         - foo: FOO
           bar: GALOOK
      - &foo_value [get_var, foo]
      - &bar_value [get_var, bar]

In the example above, when environment variable C<SELECTOR> is equal to
the string C<first_group>, then the named variable C<foo> is set to C<foo>
and the named variable C<bar> is set to C<galook>. Otherwise, if
C<SELECTOR> is equal to C<second_group>, then the named variable C<foo> is
set to uppercase C<FOO> and the named variable C<bar> to uppercase
C<GALOOK>. This will eventually set YAML anchors C<&foo_value> and
C<&bar_value> to the values that have been selected via the environment
variable.

=item * C<sprintf>

just Perl's C<sprintf>, with initial format and everything else.

=item * C<strftime>

just Perl's C<strftime> with initial format and everything else. If only
the format is provided, the rest is taken from L</gmtime> above.

=item * C<undef_default>

like L</empty_default>, but testing for undef on the first value instead
of empty. The two might be combined, of course:

    variables:
      - &default 'whatever'
      - &value   [
                    'empty_default',
                    ['undef_default', ['env', 'X'], *default],
                    *default
                 ]


=back


=head1 EXTENDING DIBS

Dibs has several dimentions for being extended.

The basic way to extend Dibs is by defining packs and sharing them (more
or less publicly): one of the main design goals of Dibs is exactly to
allow collecting common operations in the build/bundle process and reuse
them over and over. Section L</Packs> below describes the API for such
kind of extensions.

In addition to the actions explained in L</Configuration actions>, it's
also possible to define additional ones with some basic Perl code. This
is explained in L</Custom Actions>.

Last, packs themselves need not be confined in the types explained in
L</Configuration packs>. If there is the need to retrieve packs from
in other ways, they can be added to the default ones with the help of
L</Custom Pack Implementation> below.

=head2 Packs

As explained in L</Configuration packs>, a pack is basically a
definition that allows reaching some content. When this content is
needed for strokes, it is mostly in the form of programs or artifacts
needed by those programs.

A program executed in a stroke can rely upon the following information:

=over

=item *

the starting working directory is always the same as where L</envile>s
are stored. This allows easy retrieval of all enviles. C<dibs> saves a
shell script to help importing (or, actually, C<export>ing) all enviles,
called C<export-enviles.sh>.

=item *

the environment is mostly under the control of whoever edits the
configuration file (some environment variables might come from the
operative system itself, or from the base images);

=item *

the arguments provided to the program are totally under the control of
the editor of the configuration file (key L</args> in strokes)

=back

Programs can be binaries or coded in whatever language, provided that
the container image supports the right interpreter. A POSIX shell is
usually available, so it can be a good starting point.

The following shell script can be used as a base:

    #!/bin/sh
    . export-enviles.sh
    # from now on, all enviles are available as environment variables
    # e.g. src code is located in          $DIBS_DIR_SRC
    #      the cache is located in         $DIBS_DIR_CACHE
    #      the id of "this" dibs run is in $DIBS_ID

Packs can be collected into repositories (e.g.
L<dibspack-basic|http://github.com/polettix/dibspack-basic>), so
multiple programs can be packed together, also including possible
additional ancillary files (e.g. in the L<perl builder
directory|https://github.com/polettix/dibspack-basic/tree/master/perl/>,
the C<build> program relies upon C<carton> and C<cpanm>, saved in the
same directory, as well as the C<lib.sh> shell library stored one
directory above).

The standard output from a program is collected internally in Dibs (it
is currently unused); the standard error is printed out, usually
indented. For this reason, if the only goal is to print out messages, a
program might want to redirect everything to standard error at the very
beginning, e.g.:

    #!/bin/sh
    exec >&2
    . export-enviles.sh

=head2 Custom Actions

Implementing custom actions is reasonably simple and will be explained
using an example.

    package My::Example::Action;
    use Moo;
    
    with 'Dibs::Role::Action';
    
    has foo => (is => 'ro', default => 'Hello, world');
    has bar => (is => 'ro', default => 42);
    has '+output_char' => (is => 'ro', default => '*');
    
    sub execute {
       my ($self, $args) = @_;
       $self->output('foo is <' . $self->foo . '>');
       $self->output('bar is <' . $self->bar . '>');
       $self->output_marked(prefix => 'end of ');
       return $args;
    }
    
    sub parse {
       my ($self, $type, $raw) = @_;
       my ($foo, $bar) = split m{:}mxs, $raw, 2;
       return {
          type => $type,
          foo => $foo,
          bar => $bar
       };
    }
    
    1;

The action is defined in terms of a Perl class, C<My::Example::Action>
in this case. This class name is also what has to be used as C<type>
when using the action (as specified in L</Configuration actions>), like
this:

    actions:
      custom-foo:
         type: My::Example::Action
         foo: 'Hello, everybody!'
         bar: 84

The class inherits from L<Dibs::Role::Action> to get all the basic
scafoolding (e.g. a name, etc.). It's of course possible to add
action-specific parameters (like C<foo> and C<bar> in the example) as
well as overwrite part of the inherited ones (e.g. the default value for
C<output_char> is set to C<< * >> here).

The only necessary method is C<execute>, that is called when it's time
to execute the specific action. It receives a hash reference of
arguments, with keys described in L</Execution arguments>. It is
supposed to return a hash reference (usually the same a the input one);
sketches remove the C<out> field to collect all outputs (this is
currently unused).

The C<parse> method is optional, although needed to support string-based
definitions. In this case, it would be possible to compress the above
usage example as follows:

    actions:
      custom-foo: 'My::Example::Action:Hello, everybody!:84'

=head3 Execution arguments

The C<$args> parameters passed to C<execute> is a hash reference with
the following keys:

=over

=item C<env_carriers>

a reference to an array of L</Environment Carriers>, should this be
needed. For example, L<Dibs::Action::Stroke> uses this to merge all
environment variables and definitions for environment files before
saving the latter and setting the former for the run of C<docker>.

=item C<image>

is the name of the image used as a running base for adding another layer
on top. This is initially missing. A stroke will refuse to run unless
this is defined, of course, as well as a frame.

=item C<sketch>

is a reference to the innermost sketch that called the specific
action, might be missing is not executing inside a sketch.

=back

Other custom actions might add further keys. All keys are collected and
preserved across an execution of C<dibs>, which allows e.g. a C<from>
action to initialize the C<image> key that is then used by C<stroke>s
and C<frame> (if any).


=head3 Output management

Actions are strongly suggested to use the standard mechanism for
printing out information used by the rest of Dibs (including other
actions). When inheriting from L<Dibs::Role::Action>, the following
methods are available:

=over

=item C<output>

emit a string, indented.

=item C<output_marked>

emit a title-like string. Such string starts with the C<output_char>
followed by a greater-than character, then an indication of the action
type and its name, like the automatic printing of the start of an
action:

    ******> My::Example::Action custom-foo

It can be used to print additional such messages, e.g. in our example at
the end the following is printed:

    ******> My::Example::Action end of custom-foo

=back

When the example class is used, the following is printed:

    ******> My::Example::Action custom-foo
            foo is <Hello, everybody!>
            bar is <84>
    ******> My::Example::Action end of custom-foo

When an instance of the class is created, the C<create> method is
called, which is inherited by default from L<Dibs::Role::Action> (it
just calls C<new>). It's possible to override it to get a custom
constructor.

=head2 Custom Pack Implementation

To be... written.


=head1 DIAGNOSTICS

Whatever fails will complain quite loudly.


=head1 DEPENDENCIES

See L<https://github.com/polettix/dibs/blob/master/cpanfile>.

C<dibs> is also a C<dibs> project itself; chances are that the
C<polettix/dibs> Docker image available at
L<https://hub.docker.com/r/polettix/dibs/> suffices for just using it.

=head1 BUGS AND LIMITATIONS

Please report any bugs or feature requests through the repository at
L<https://github.com/polettix/dibs>.

Reading configurations from the C<dibs.yml> file is somehow liberal,
allowing the presence of keys that are not required or used by C<dibs>.
This might be regarded as a limitation because it makes C<dibs> prone to
typos.


=head1 AUTHOR

Flavio Poletti C<polettix@cpan.org>


=head1 LICENCE AND COPYRIGHT

Copyright (c) 2018, 2019 Flavio Poletti C<polettix@cpan.org>.

This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0.

This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut
