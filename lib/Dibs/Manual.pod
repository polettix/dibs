=encoding utf8

=head1 NAME

dibs - Docker Image Build System

=head1 VERSION

C<dibs>'s version can be retrieved with option L</--version>:

   shell$ dibs --version

=head1 USAGE

   dibs [--usage] [--help] [--man] [--version]

   dibs [--alien|-A]
        [--change-dir|-C directory]
        [--config-file|--config|-c filename]
        [--dirty|--dirty-origin-is-ok|-D]
        [--loglevel|-l levelname]
        [--origin|-O URI]
        [--project-dir|-p directory]
        [--verbose|-v]
        action [action [action...]]

=head1 EXAMPLES

   # A repo like `dibs` itself, there's a dibs.yml file at the root and
   # this is all that's needed for a "development" run from the root dir
   $ dibs

   # Ditto, but changing directory first
   $ dibs -C /path/to/simple/repo

   # The repo itself might not be aware of the whole dibs part, or take
   # care of a few aspects only to minimise burden on developers. In this
   # case the starting point is a project directory
   $ dibs --alien -C /path/to/project/dir

   # Configuration file is named "dibs.yml" by default, but it's possible
   # to keem more of them around
   $ dibs -c alt-dibs.yml

=head1 DESCRIPTION

C<dibs> allows handling the different steps of building software and
packing it as a I<trimmed> Docker image. A gentle introduction to its
goals and to some examples is provided at
L<https://github.com/polettix/dibs>; this manual page will only provide
lower-level details about using the program itself.

C<dibs> uses a I<project directory> as a basecamp for all operations.
C<dibs> can be run in two modes: I<development> (the default one) and
C<alien>. The only difference between the two is the directory layout:
in C<development mode> a subdirectory C<dibs> is created and used as
C<project directory>, while in C<alien mode> the current directory is
used.

C<dibs> allows executing programs inside containers and optionally save
the results as container images. It manages multiple different I<phases>
of execution, allowing e.g. to distinguish a I<build> phase leveraging a
fat image with many tools installed (e.g. a compiler) and a I<bundle>
phase to generate a lean image. The definition of all possible
I<actions> is done through a configuration file called C<dibs.yml>,
located in the project directory's root.

C<dibs> mounts several directories in a container when it runs programs
inside of them. This allows pass information to and from containers in a
systematic way; more info on L</Directories> is available below.

The I<actions> defined in the configuration file can be of different
types:

=over

=item I<prepare>

this action sets up the stage for running a container, it's the
equivalent of the C<FROM> directive in the Dockerfile

=item I<stroke>

this action executes a program inside a container

=item I<frame>

this action saves a container as an image

=item I<sketch>

groups multiple actions in a sequence

=back

=head2 Anatomy of a Run

In this section, the following layout is assumed:

    project/
      cache/
      dibs.yml
      env/
         sample-file.json
      src/
         app.pl
         cpanfile

The current working directory is assumed to be C<project>. This is the
typical layout for L</Alien mode>, where the project directory tracks a
(potentially) remote project that is unaware of C<dibs> (or not directly
involved).

When C<dibs> is run:

    $ dibs --alien

the following happens:

=over

=item *

command-line options are parsed. In this case, the C<--alien> option
sets C<dibs> up to expect the directory layout above

=item *

the configuration file C<dibs.yml> is loaded and parsed lazily (i.e. its
parts are expanded only when strictly needed).

=item *

the actions to be executed are collected. In this case there is no
explicit indication in the command line, so an action named C<default>
is looked for in the loaded configuration

=item *

each action is executed in the order specified.  Top level actions are
I<sketches> that start from a I<prepare> action, usually followed by
some I<strokes> and optionally terminated with a I<frame> that saves the
image. In particular, for I<stroke> actions:

=over

=item *

a directory C<envile> is created and several files are saved inside,
representing key-value pairs

=item *

a container is run, with most of the directories in the project mounted
inside (read-only or read-write, depending on the directory).

=back

=back

Programs executed in a stroke can be local or remote (e.g. in a `git`
repository); to help locate the right artifacts, C<dibs> introduces the
concept of I<pack> (also called C<dibspack>). In some contexts, packs
(especially remote ones) can also hold additional configurations.

Within a container, many data are available in the form of so-called
I<enviles>. An envile is just a variable passed through a file in the
L</envile> directory, much like an environment variable.

=head2 Directories

There are several directories of interest in C<dibs>, explained in the
following sections; unless otherwise noted, they are all sub-directories
of the I<project directory>. The generic complete layout is as follows
(directories that are also mounted in the container and the envile that
holds their position is also indicated)

    directory in host | envile in container | notes
    ------------------+---------------------+----------------------
    project/          |                     |
      auto/           |                     |
         host-only/   |                     |
         open/        | DIBS_DIR_AUTOPACK   |
      cache/          | DIBS_DIR_CACHE      |
      env/            | DIBS_DIR_ENV        |
      envile/         | DIBS_DIR_ENVILE     | container working dir
      pack/           | DIBS_DIR_PACK       |
      src/            | DIBS_DIR_SRC        |


=head3 C<auto>

This directory is used for retrieving and locally store remote or
dynamic packs. It has two sub-directories:

=over

=item C<host-only>

this directory contains packs whose goal is only to carry additional
configurations, which are of interest only in the host and not inside
the containers. This directory is not mounted in the container.

=item C<open>

this directory contains packs that are of interest inside the container.
It is mounted read-only and its location is stored in envile
C<DIBS_DIR_AUTOPACK>.

=back

This directory is managed by C<dibs> automatically and should not be
used otherwise.

=head3 C<cache>

This directory is meant as a repository for easing communication across
different phases of execution (i.e. potentially across independent
containers).

It is mounted read-write and its management is completely under user's
control; its position is saved in envile C<DIBS_DIR_CACHE>.

=head3 C<env>

This directory is meant to hold whatever the user sees fit. It is
mounted read-only inside the container, its position stored in envile
C<DIBS_DIR_ENV>.

=head3 C<envile>

This directory holds files representing environment variables: filenames
are the variable's names, file contents are the associated values. In
addition, a file C<export-enviles.sh> is also saved, to help loading the
variables in a shell script.

The choice to save variables as files stems from the fact that
environment variables are saved in a container's layer permanently,
which can be undesired for some values (e.g. passwords, or transient
values).

This directory is generated and managed by C<dibs> and should not be
used otherwise (it is wiped out when needed). To save specific data, the
C<env> directory should be used instead.

This directory is mounted read-only and is also set as the initial
working directory in each container that is started, so that e.g. the
location of all other directories can be found easily; in any case, its
position is also stored in envile C<DIBS_DIR_ENVILE>.

=head3 C<pack>

This directory aims at containing programs to be executed inside the
containers, or their associated artifacts (e.g. other programs).

Remote programs that are fetched e.g. via `git` are not placed here, but
inside L</auto> instead; this directory is meant for storing programs
that are specific to the project.

The directory is mounted read-only, its position available in envile
C<DIBS_DIR_PACK>.

=head3 C<src>

This directory is assumed to carry the project's source code. It can be
populated externally or automatically by C<dibs>. It is mounted
read-write and its position is available in envile C<DIBS_DIR_SRC>.

In C<development mode> the directory is populated automatically based on
the code's local git setup (i.e. the code MUST be tracked via `git`); in
C<alien mode> it might be assumed to be populated externally, or
populated automatically using the L</origin> directive.

=head2 Modes Of Operation

There are two main modes of operations, explained in the following
sections.

=head3 Alien mode

This mode is useful when a remote source project is tracked. The source
project might even be unaware of C<dibs> completely.

The typical layout is the following:

    project-directory/
      auto/
         host-only/
         open/
      cache/
      dibs.yml
      env/
      envile/
      pack/
      src/

In alien mode, the working directory (the current one, or the one after
changing it via L</--change-dir>) is coincident with the project
directory; additionally, no automatic origin is set, so the C<src>
sub-directory is either otherwise-populated (e.g. directly edited,
independently expanded from a tar file, etc.) or the real origin has to
be set explicitly.

=head3 Developer mode

This mode is useful for developers that want to leverage C<dibs>
directly in their code layout. This is also the default mode of
operation (in lack of C<--alien> or equivalent options).

In developer mode, the typical layout is as follows:

    code-source-root/
      .git
      ah-some-code.pl
      ah-other-code.c
      dibs.yml
      dibs/
         auto/
            host-only/
            open/
         cache/
         env/
         envile/
         pack/
         src/

In this case, the source is edited in the top tree (C<code-source-root>
in the example) and then transferred inside C<src> at the beginning. As
a matter of fact, the code is I<checked out>, which implies that:

=over

=item *

the base source directory MUST be tracked with `git`, and

=item *

the changed code MUST be committed to be used.

=back

The above behaviour is obtained by automatically setting the I<origin>
(L</--origin>) to C<.>, assuming that the C<dibs> command is run from
the code's root directory.

In case the `git` repository is not in a clean state, the C<dibs>
command will complain. This will prevent running it e.g. in case the
user forgets to commit the work before running C<dibs>. It is possible
to override this safecheck using option L</--dirty>, although this is
probably only useful only when modifying the C<dibs.yml> file itself (it
is always taken from the original directory if present).

=head1 OPTIONS

C<dibs> supports some command line options. Some of them are I<meta>, in
the sense that their goal is to provide information about C<dibs> itself;
other options are actually used by C<dibs> to do its intended job.

=head2 Meta-Options

The following I<meta-options> allow getting more info about C<dibs>
itself:

=over

=item --help

print a somewhat more verbose help, showing usage, this description of
the options and some examples from the synopsis.

=item --man

print out the full documentation for the script.

=item --usage

print a concise usage line and exit.

=item --version

print the version of the program.

=back


=head2 Real Options

The following options are supported by C<dibs> as part of its mission. The
are reported both as environment variables (all uppercase, no leading
dash) and as command line options; when both are present, the command line
option takes precedence.

The values cannot in general be overridden from configurations coming from
the configuration file; any exception is explicitly acknowledged.

=over

=item --alien

=item -A

=item DIBS_ALIEN

   $dibs --alien

set the L</Alien mode> directory layout.

=item --change-dir

=item -C

=item DIBS_CHANGE_DIR

   $ dibs --change-dir /path/to/whatever

change directory as soon as possible and continue operations from there.
This allows e.g. having ugly wrappers to change directory before running
C<dibs> itself, which is useful especially when using the Docker image for
C<dibs>.

Optional parameters, default is to operate from current directory.

This is considered only before loading a configuration file, so any
setting inside the configuration file is ignored.

=item --config-file

=item --config

=item -c

=item DIBS_CONFIG_FILE

   $ dibs --config-file dibs-alternative.yml

set name of the configuration file. Defaults to C<dibs.yml>.

In L</Alien mode>, a relative path is referred to the project directory.
In L</Developer mode>, though, a relative path is first looked for
starting from the current directory, then from the project directory.
This allows keeping the C<dibs.yml> file in the code's root directory.

This is considered only before loading a configuration file, so any
setting inside the configuration file is ignored.

=item --dirty

=item -D

=item DIBS_DIRTY

   $ dibs --dirty

allow for a dirty origin repository. When an origin repository is set
for cloning/checking out L</src>, C<dibs> checks its state (if local)
and refuses to proceed if it is dirty (i.e. with uncommitted changes
and/or untracked files); this is useful in L</Developer mode> to prevent
running C<dibs> without recent changes.

It is generally advised to avoid this option. A notable exception is
when changing the C<dibs.yml> file itself in L</Developer mode>, because
the one in the main directory is taken directly.

=item --origin

=item -O

=item DIBS_ORIGIN

   $ dibs -O /path/to/origin.git

set a I<Git origin> from where C<src> will be cloned.

The clone is performed in the I<host context>, before the containers are
invoked. It is always done at the beginning and only once per invocation,
even in steps that technically do not rely on it (C<dibs> has no way to
tell).

The origin can be set inside the C<dibs.yml> file.

In L</Developer mode>, this option is set automatically to C<.>.

=item --project-dir

=item -p

=item DIBS_PROJECT_DIR

   $ dibs --project-dir directory

set the base directory of the project.

By default (i.e. L</--alien> is not set) it is the C<dibs> sub-directory
of the current directory (after L</--change-dir>).

In L</Alien mode> it defaults to the current directory (after
L</--change-dir>).

This option is computed before loading the configuration file and cannot
be overridden even when missing from environment and/or command line.

=item --verbose

=item -v

=item DIBS_VERBOSE

   $ dibs --verbose

Enable additional information during execution.

=back

I<Straight> command line arguments represent actions to be executed in
the specific run (by default, an action named C<default> is executed):

   $ dibs first second third fourth last

It defaults to whatever is found inside the C<dibs.yml> configuration
file. The example above leads to the following list of steps:

   - first
   - second
   - third
   - fourth
   - last


=head1 CONFIGURATION

Invocation of C<dibs> is explained in section L</OPTIONS>, which includes
command-line options and environment variables.

The core of the configuration for C<dibs> comes from the C<dibs.yml>
configuration file (but see L<--config-file>). This file has
a I<free-form>, in that only a few keys are meaningful to C<dibs> and the
rest is up to the writer (e.g. to concentrate other configurations that
can be of help for other tools).

Higher level keys are:

=over

=item C<defaults>

set defaults that can be reused around.

=item C<definitions>

define what each I<step> is supposed to do

=item C<name>

main name of the project (may be overridden in one or more steps)

=item C<steps>

list of steps to take. This can be overridden by command-line argument.

=back

=head2 C<defaults>

Associative array.

It is a best practice to put a sub-key C<variables> with the definition of
(YAML) variables that can be reused around as an array, like this:

   defaults:
      variables:
         - &base_image 'alpine:3.6'
         - &version 'DIBSPACK_SET_VERSION="0.001972"'
   ...
   definitions
      foo:
         from: *base_image

There is more to it anyway: if the item is a hash reference with a single
key C<function> whose associated value is an array, like in this example:

   defaults:
      variables:
         - &version_major           '0'
         - &version_minor           '1'
         - &version_patch           '1'
         - function: &version
            ['join', '.', *version_major, *version_minor, *version_patch]
         - function: &version_maj_min
            ['join', '.', *version_major, *version_minor]

then the first item in the array is taken as a I<function> name and the
rest as its arguments. Currently the following functions are supported:

=over

=item * C<join>

behaves like the Perl counterpart, taking the first parameter as separator
and joining the rest with it. In the example above, the first is expanded
as C<0.1.1> and the second one as C<0.1>.

=back


C<dibs> also recognizes sub-key C<dibspack>, allowing the definition of
several set of defaults for dibspacks. They can be used both I<the YAML
way> (note the anchor in the C<user> default dibspack):

    defaults:
       dibspack:
          user: &user
             type: src
             name: add user and enable for docker
             user: root
             path: dibspacks/user-docker.sh
    definitions:
       foo:
          dibspacks:
             - *user

or the C<dibs> way, that allows overriding parameters too:

    defaults:
       dibspack:
          basic:
             type:   git
             origin: https://github.com/polettix/dibspack-basic.git
             user:   user
    definitions:
       foo:
         ...
          dibspacks:
             - default: basic
               path: perl/build
               args: ['/app', 'ANOTHER=ENVIRONMENT_VARIABLE']

In this case, the key C<default> allows importing the whole block of the
associated entry in C<defaults> and then override values as needed.

=head2 C<definitions>

Associative array where the operations of each step can be defined. Keys
are names that can be used when defining the list of steps (see below),
values are associative arrayes themselves, where the following keys are
recognized:

=over

=item C<commit>

Boolean or associative array for committing a container as an image. Inthe
latter case, it supports the following keys:

=over

=item C<cmd>

String or list, has the same meaning as in the Dockerfile. Defaults to an
empty list.

=item C<entrypoint>

String or list, has the same meaning as in the Dockerfile. Defaults to
a list with strings C</bin/sh> and C<-l>, in order.

=item C<keep>

Boolean (either YAML or Perl), sets whether the resulting container of the
step should be kept as a Docker image or ditched away. Defaults to a true
value when absent; it is mostly useful to temporarily avoid generating an
image (e.g. to just check that the steps run fine), otherwise the whole
C<commit> section make little sense.

=item C<name>

String, overrides the global C<name> within the step and is used for
setting the name of the image. When absent, the C<name> at the YAML
highest level is taken.

=item C<tags>

List of strings, provides either tags or fully qualified names for images.

Any container is initially started from an image name that is generated
automatically, based on C<name> and a timestamp. This tag is eventually
dropped, unless the special tag C<*> (or its alias C<:default:>) are put
in the list. The automatically generated tag is also kept if there are no
tags in the list (or there is not C<tag> key at all).

=item C<user>

String, has the same meaning as in the Dockerfile.

=item C<workdir>

String, has the same meaning as in the Dockerfile.

=back


=item C<dibspacks>

Array of associative arrays, each specifying a dibspack to execute (in the
same order as they appear in the array. See below for details.

=item C<from>

String, has the same meaning as in the Dockerfile, i.e. specify a base
image where to start from.

=back

The C<dibspacks> array provides a list of dibspacks to execute, in the
same order as they appear. Each is an associative array itself, where the
following keys are recognized:

=over

=item C<args>

list of additional arguments passed to the program run in the dibspack
(the first three arguments are fixed and are always the C<src>, C<cache>
and C<env> directory paths inside the container).

=item C<default>

import key-value pairs from the relative entry in associative array inside
C<defaults.dibspacks>.

=item C<type>

The dibspack type, might be one of C<git>, C<immediate>, C<inside>,
C<project>, or C<src>. See relevant sections below for more details.

=item C<user>

the user for running the container, defaults to C<root>.

=back

=head3 Dibspack type C<git>

The dibspack can be retrieved from a git repository. The following
additional sub-keys are available:

=over

=item C<origin>

the URI of the git repository. It can also have a fragment part (after
a C<#> sign>) specyfing a ref to checkout.

=item C<path>

path to the dibspack program inside the repository. This allows having
multiple dibspack programs inside the same repository, like
L<https://github.com/polettix/dibspack-basic>.

=item C<ref>

the specific reference to checkout from the repository.

Note that the C<origin> might have a I<fragment> part (i.e. a dash C<#>
sign followed by the I<fragment string>) that is interepreted as a C<ref>
as well. In this case C<ref> cannot be present too.

=back

Example:

   ...
   - type:   git
     origin: https://github.com/polettix/dibspack-basic.git
     ref:    master
     path:   perl/build
     args:   ['/app', 'HEY=JOE']
     user:   user

=head3 Dibspack type C<immediate>

This dibspack is a program whose code is provided in the YAML definition
itself, inside key C<program>. Example:

   ...
   - type: immediate
     program: |
         #!/bin/sh
         printf '%s\n' 'Hello, world!'

=head3 Dibspack type C<inside>

This dibspack allows calling a program that is I<already> inside the
container. This might probably not be a good idea, but who knows.

Accepts an additional key C<path> with the absolute path to the program
inside the container.

=head3 Dibspack type C<project>

This dibspack type allows calling a dibspack inside the C<dibspacks>
directory inside the project directory.

Accepts an additional key C<path> with a path that is always interpreted
as relative to that directory.

=head3 Dibspack type C<src>

This dibspack type allows calling a dibspack inside the C<src> directory.

Accepts an additional key C<path> with a path that is always interpreted
as relative to that directory.


=head2 C<name>

String, name of the project. This is also what saved Docker images are
named by default, although this can be overridden inside each step.

=head2 C<steps>

This is just a list of strings. Each must be the identifier of a valid
definition inside L<< /C<definitions> >>. Example:

   definitions:
      foo:
         ...
      bar:
         ...
      baz:
         ...
   steps:
      - bar
      - foo
      - baz
      - foo


=head1 DIAGNOSTICS

Whatever fails will complain quite loudly.


=head1 DEPENDENCIES

See C<cpanfile>.

C<dibs> is also a C<dibs> project itself, compilable in L</Local mode>;
chances are that the C<polettix/dibs> Docker image available at
L<https://hub.docker.com/r/polettix/dibs/> suffices for just using it.

=head1 BUGS AND LIMITATIONS

Please report any bugs or feature requests through the repository at
L<https://github.com/polettix/dibs>.

Reading configurations from the C<dibs.yml> file is somehow liberal,
allowing the presence of keys that are not required or used by C<dibs>.
This might be regarded as a limitation because it makes C<dibs> prone to
typos.


=head1 AUTHOR

Flavio Poletti C<polettix@cpan.org>


=head1 LICENCE AND COPYRIGHT

Copyright (c) 2018, Flavio Poletti C<polettix@cpan.org>.

This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0.

This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut
