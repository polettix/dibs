package Dibs::Action::Factory;
use 5.024;
use Ouch ':trytiny_var';
use Log::Any '$log';
use Dibs::Config ':constants';
use Module::Runtime 'use_module';
use Try::Catch;
use Scalar::Util 'refaddr';
use Guard;
use Moo;
use experimental qw< postderef signatures >;
no warnings qw< experimental::postderef experimental::signatures >;

# line of generation of this specific factory. All items generated by
# this factory. Pristine factory has this empty, then...

has context      => (is => 'ro', default  => undef);
has name         => (is => 'ro', default  => undef);
has pack_factory => (is => 'ro', required => 1);
has zone_factory => (is => 'lazy');

with 'Dibs::Role::Factory';

sub _add_context ($self, $feedback) {
   defined(my $ctx = $self->context) or return $feedback;
   return "$feedback (\@$ctx)";
}

sub _build__class_for ($self) {
   return {
      &SKETCH => 'Dibs::Action::Sketch',
      &GIT    => 'Dibs::Action::Fetch::Git',   # FIXME implement
      &HTTP   => 'Dibs::Action::Fetch::Http',  # FIXME implement
      &FRAME  => 'Dibs::Action::Frame',
      &LOG    => 'Dibs::Action::Log',
      &FROM   => 'Dibs::Action::Prepare',
      &PACK   => 'Dibs::Action::Stroke',
      &STROKE => 'Dibs::Action::Stroke',
   };
}

sub pre_inflate ($self, $x, %args) {
   my $ref = ref $x;
   return $x if $ref eq 'HASH';
   return {type => SKETCH, actions => $x} if $ref eq 'ARRAY';
   ouch 400, "invalid input for instance ($ref -> $x)" if $ref ne '';

   if (my ($type, $raw) = $x =~ m{\A (.*?) : (.*) \z}mxs) {
      my $class = $self->class_for({type => $type}, %args);
      return $class->parse($raw);
   }

   # last resort, it might be a reference to something else
   return $x;
}

sub normalize ($self, $x, %args) {
   ouch 400, 'normalize requires a HASH' unless ref $x eq 'HASH';
   $x->{type} //= $self->_dwim_type($x);
   return $x;
}

sub _dwim_type ($self, $spec) {
   return $spec->{type} if exists $spec->{type};

   return SKETCH if exists $spec->{actions};
   return STROKE if exists $spec->{pack};
   return FROM if exists $spec->{from};
   return FRAME if exists($spec->{image_name}) || exists($spec->{tags});

   return;
}

sub _clone_ancestors ($self, $override) {
   return [($override // $self->ancestors)->@*];
}

sub _build_zone_factory ($self) { $self->pack_factory->zone_factory }

1;
__END__

sub _old_create_instance ($self, $type, %args) {
   ouch 400, 'missing action type' unless defined $type;
   state $class_for = {
      &SKETCH => 'Dibs::Action::Sketch',
      &GIT    => 'Dibs::Action::Fetch::Git',
      &HTTP   => 'Dibs::Action::Fetch::Http',
      &FRAME  => 'Dibs::Action::Frame',
      &LOG    => 'Dibs::Action::Log',
      &FROM   => 'Dibs::Action::Prepare',
      (
         map { $_ => ('Dibs::Action::Stroke::' . ucfirst(lc $_)) }
            (INSIDE, PROJECT, SRC),
      ),
      (
         map { $_ => 'Dibs::Action::Stroke::Immediate' }
            (IMMEDIATE, 'run', 'program'),
      ),
      &PACK   => 'Dibs::Action::Stroke',
   };
   my $class = $class_for->{$type} // $type;

   try { use_module($class) }
   catch { ouch 400, "invalid action type '$type' ($_)" };

   $args{spec} = $class->parse(delete $args{raw})
     if exists($args{raw}) && ! exists($args{spec});

   return $class->create(%args, factory => $self, type => $type);
} ## end sub _create_instance

sub old_instance ($self, $x, %args) {

   # FIXME add protection against circular dependency here or where it
   # belongs

   my $ref = ref $x;
   return $self->_instance_for_array($x, \%args) if $ref eq 'ARRAY';
   return $self->_instance_for_hash($x, \%args) if $ref eq 'HASH';

   ouch 400, "invalid input for instance ($ref -> $x)" if $ref ne '';

   # type:raw-data-to-be-parsed-for-type
   return $self->_instance_for_rawspec($x, \%args)
     if $x =~ m{\A \w+ [:] }mxs;

   # name@some-other-context
   return $self->_instance_for_remote($x, \%args)
     if $x =~ m{\A \w+ [@] }mxs;

   # name of something in the current context
   return $self->_instance_for_name($x, \%args);
} ## end sub instance

