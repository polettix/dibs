package Dibs::Action::Factory;
use 5.024;
use Ouch ':trytiny_var';
use Log::Any '$log';
use Dibs::Config ':constants';
use Module::Runtime 'use_module';
use Try::Catch;
use Scalar::Util 'refaddr';
use Guard;
use Moo;
use experimental qw< postderef signatures >;
no warnings qw< experimental::postderef experimental::signatures >;

# line of generation of this specific factory. All items generated by
# this factory. Pristine factory has this empty, then...

has context      => (is => 'ro', default  => undef);
has name         => (is => 'ro', default  => undef);
has pack_factory => (is => 'ro', required => 1);
has zone_factory => (is => 'lazy');

with 'Dibs::Role::Factory';

sub _add_context ($self, $feedback) {
   defined(my $ctx = $self->context) or return $feedback;
   return "$feedback (\@$ctx)";
}

sub _build__class_for ($self) {
   return {
      &SKETCH => 'Dibs::Action::Sketch',
      &GIT    => 'Dibs::Action::Fetch::Git',   # FIXME implement
      &HTTP   => 'Dibs::Action::Fetch::Http',  # FIXME implement
      &FRAME  => 'Dibs::Action::Frame',
      &LOG    => 'Dibs::Action::Log',
      &FROM   => 'Dibs::Action::Prepare',
      &PACK   => 'Dibs::Action::Stroke',
      &STROKE => 'Dibs::Action::Stroke',
   };
}

around pre_inflate => sub ($orig, $self, $x, %args) {
   return {type => SKETCH, actions => $x} if ref($x) eq 'ARRAY';
   return $self->$orig($x, %args);
};

sub normalize ($self, $x, %args) {
   ouch 400, 'normalize requires a HASH' unless ref $x eq 'HASH';
   $x->{type} //= $self->_dwim_type($x);
   return $x;
}

sub _dwim_type ($self, $spec) {
   return $spec->{type} if defined $spec->{type};

   return SKETCH if exists $spec->{actions};
   return STROKE if exists $spec->{pack};
   return FROM if exists $spec->{from};
   return FRAME if exists($spec->{image_name}) || exists($spec->{tags});
   return LOG if exists($spec->{dump}) || exists($spec->{message});

   return;
}

sub _build_zone_factory ($self) { $self->pack_factory->zone_factory }

1;
__END__
