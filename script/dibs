#!/usr/bin/env perl
use 5.024;
use warnings;
use Dibs;
use Path::Tiny;

exit Dibs->main(@ARGV);

sub version {
   my $version = $ENV{VERSION};

   if (! defined $version) {
      my $version_file = path(__FILE__)->sibling('VERSION');
      chomp($version = $version_file->slurp_utf8) if $version_file->exists;
   }

   # last resort, a default value
   $version //= '0.001972';

   for my $key (qw< GIT_REF DIBS_ID DIBS_FROM_IMAGE >) {
      next unless defined $ENV{$key};
      (my $name = lc $key) =~ s{_}{-}gmxs;
      $version .= " ($name $ENV{$key})";
   }

   return $version;
}

__END__

=encoding utf8

=head1 NAME

dibs - Docker Image Build System

=head1 VERSION

Ask the version number to the script itself, calling:

   shell$ dibs --version

=head1 USAGE

   dibs [--usage] [--help] [--man] [--version]

   dibs [--change-dir|-C directory]
        [--config-file|--config|-c filename]
        [--local|-l|--no-local]
        [--project-dir|-p directory]
        step [step [step...]]

=head1 EXAMPLES

   # A repo like `dibs` itself, there's a dibs.yml file at the root and
   # this is all that's needed for a "local" run if you are in the root dir
   $ dibs -l

   # Ditto, but change directory first
   $ dibs -lC /path/to/simple/repo

   # The repo itself might not be aware of the whole dibs part, or take
   # care of a few aspects only to minimise burden on developers. In this
   # case the starting point is a project directory
   $ dibs -C /path/to/project/dir

   # Configuration file is named "dibs.yml" by default, but it's possible
   # to keem more of them around
   $ dibs -c alt-dibs.yml


=head1 DESCRIPTION

C<dibs> allows handling the different steps of building software and
packing it as a I<trimmed> Docker image. The full details can be found in
the documentation, e.g. at L<https://github.com/polettix/dibs>; this
manual page will only provide lower-level details about using the program
itself.

=head2 Basic Concepts

At its very basics:

=over

=item *

a run of C<dibs> goes through one or more I<steps>, each invoking zero or
more I<dibspack>s. A C<dibspack> is a program that allows executing an
operation within a container inside the specific step. Each step's final
resulting container can be kept or thrown away.

=item *

C<dibs> operates in the context of a I<working directory>. This directory
contains different sub-directories that will be bind-mounted inside the
container and made accessible to the processes inside, for building and
bundling purposes.

=back

=head3 Directories

There are several directories that are of interest in C<dibs>:

=over

=item C<cache>

this directory allows keeping stuff across different steps in an
invocation of C<dibs>, or across multiple invocations.

=item C<dibspacks>

this directory holds the dibspacks that will be executed

=item I<empty>

this is an empty directory that is bind-mounted over the project directory
when running in L<--local> mode (when this directory is usually
a sub-directory of C<src> below). It is empty and not writeable, so it has
only masking purposes.

=item C<env>

this directory allows keeping read-only files that might be useful for
customizing a project

=item C<project>

this directory is a sort of "headquarters" for a C<dibs> project. It will
always contain C<cache>, C<dibspacks> and C<env> inside. Depending on the
setup, it can also contain either C<empty> or C<src>.

=item C<src>

this directory holds the source code that should be built and bundled

=back

There are two kind of setups, depending on command line argument
C<--local>. When it is not present, or C<--no-local> is provided, the
layout is the I<traditional> one:

   <<project>>
   + cache
   + dibspacks
   + env
   + src

In I<local> mode, instead (i.e. C<--local> enabled) the typical layout is
the following instead:

   <<src>>
   + .dibs     # name of the <<project>> dir
     + cache
     + dibspacks
     + empty
     + env

Independently of the layout, the following mounts inside the container are
performed:

   cache      -->  /tmp/cache
   dibspacks  -->  /tmp/dibspacks
   env        -->  /tmp/env
   src        -->  /tmp/src

although dibspacks are encouraged to use the first three parameters to get
the actual position of C<cache>, C<env> and C<src> (they should not care
about C<dibspacks>).

In a local setup, where the project directory is inside C<src>, the
following mount is also performed:

   empty      -->  /tmp/src/.dibs

(or whatever the L<--project-dir> is set to). This hides the whole project
dir inside the source directory, e.g. making it easy to copy the whole src
to another destination without C<dibs> project artifacts getting in the
way.

=head2 Project Modes

C<dibs> supports a few I<modes of operation> that basically boild down to
select the right project directory position and layout. They are:

=over

=item *

I<development> mode (which is also the default), where the current
directory is a git repository and C<dibs> is supposed to I<clone> at the
beginning. The project directory is created as a subdirectory.

=item *

I<local> mode, where the current directory is used directly as the source
directory. The project directory is created as a subdirectory.

=item *

I<alien> mode, where the current directory is (by default) the I<project
directory> where C<dibs> operates. The C<src> directory inside it is where
the code is supposed to be; it can either fetched at the beginning (via
L</--origin>) or not.

=back

As a rule of thumb, developers that also take care of direct packaging of
Docker images will work in I<development> mode (i.e. the default), while
teams packaging code from a remote repository will work in I<alien> mode.
I<Local> mode should normally be avoided.

=head3 Development mode

In this mode, the directory layout is the following:

   <git-repo>
   + dibs
     + cache
     - [dibs.yml]
     + dibspacks
     + env
     + src
   - [dibs.yml]

where C<src> is cloned from C<< <sgit-repo> >> at the beginning of
operations.

The project directory defaults to C<dibs> inside the current directory,
although this can be changed with option C<--project-dir>.

The C<dibs.yml> file can be put either in the C<< <git-repo> >> itself, or
inside the project directory. The first has the precedence though.


A typical use case (which also gives the name to the mode) is the
following:

=over

=item *

the C<< <git-repo> >> is a working directory where the developer works on
the code;

=item *

when ready for packading an image, the developer commits the changes and
runs C<dibs>;

=item *

there is no step three, the developer restarts working from step one.

=back

FIXME dirty directory FIXME

Another possible use case is the following:

=over

=item *

the C<< <git-repo> >> is a bare git directory, used as a remote/central
repository by the development team;

=item *

there is a git hook configured to run C<dibs> automatically when new
changes are pushed to this repository.

=back

=head3 Alien mode

In this mode, the directory layout is the following:

   <project>
   + cache
   - dibs.yml
   + dibspacks
   + env
   + src

It is upon the team managing the project to make sure that the C<src>
directory is properly populated with the code from the development team.
As an option, C<dibs> can clone a git repository if option L<--origin> is
also set.

In this case, it might well be that the C<dibspacks> directory is
populated with project-specific dibspacks; note that the same directory is
also used for automatically generated/retrieved dibspacks, which means
avoding using file names C<git> and C<immediate> inside the directory.

When running in I<alien> mode, the current working directory is assumed to
be the project directory. This can be changed with option
C<--project-dir>.

The configuration file C<dibs.yml> must be contained in the project
directory.

A typical use case for this mode is the following:

=over

=item *

development and packaging activities are performed by different teams and
tracked in different repositories. The development team might even be
unaware of packaging activities through C<dibs>.

=item *

the packaging team has (read-only) access to the development code, and
performs packaging activities when deemed necessary. It also develops any
necessary dibspack for properly building/packaging the code.

=back

A totally different use case might be the following:

=over

=item *

the developer adopts the layout above and does code development directly
inside C<src>

=item *

when ready for packaging the code in a Docker image, the developer runs
C<dibs> inside the C<< <project> >> directory.

=back

Note that this latter mode of operations might make it more difficult to
track the changes to the project, so it's adviseable to revert to
C<development> mode instead.

=head3 Local mode

In this mode, the directory layout is the following:

   <src>
   + dibs
     + cache
     - [dibs.yml]
     + dibspacks
     + empty
     + env
   - [dibs.yml]

The current (top) directory is used as C<src> directly, without creating
the C<src> directory inside the project directory (that defaults to
C<dibs> inside it).

This mode of operations might come handy in I<hackish> situations, but the
packaging might take a dirty condition in consideration and make the
process less replicable and more brittle. It is in general adviseable to
avoid this mode of operation and revert to C<development> mode instead.

The project directory is created automatically by C<dibs> in this case, if
it does not exists. In this case, when the C<src> directory is mounted,
its sub-directory holding the project (C<.dibs> by default and in the
example above) is I<hidden> by bound-mounting C<empty> over it. This is
not a security measure, but a simplification for handling C<src> inside
the container, e.g. to copy all of its content to another destination
without also copying the project-specific files.

The configuration file C<dibs.yml> can be either contained in the C<src>
or in the project sub-directory (they are searched in this order).

When running in I<local> mode, the current working directory is assumed to
be C<src>.

=head1 OPTIONS

C<dibs> supports some command line options. Some of them are I<meta>, in
the sense that their goal is to provide information about C<dibs> itself;
other options are actually used by C<dibs> to do its intended job.

=head2 Meta-Options

The following I<meta-options> allow getting more info about C<dibs>
itself:

=over

=item --help

print a somewhat more verbose help, showing usage, this description of
the options and some examples from the synopsis.

=item --man

print out the full documentation for the script.

=item --usage

print a concise usage line and exit.

=item --version

print the version of the program.

=back


=head2 Real Options

The following options are supported by C<dibs> as part of its mission. The
are reported both as environment variables (all uppercase, no leading
dash) and as command line options; when both are present, the command line
option takes precedence.

The values cannot in general be overridden from configurations coming from
the configuration file; any exception is explicitly acknowledged.

=over

=item --alien

=item -A

=item DIBS_ALIEN

   $dibs --alien

set the L</Alien mode> directory layout.

=item --change-dir

=item -C

=item DIBS_CHANGE_DIR

   $ dibs --change-dir /path/to/whatever

change directory as soon as possible and continue operations from there.
This allows e.g. having ugly wrappers to change directory before running
C<dibs> itself, which is useful especially when using the Docker image for
C<dibs>.

Optional parameters, default is to operate from current directory.

This is considered only before loading a configuration file, so any
setting inside the configuration file is ignored.

=item --config-file

=item --config

=item -c

=item DIBS_CONFIG_FILE

   $ dibs --config-file dibs-alternative.yml

set name of the configuration file. Defaults to C<dibs.yml>.

In L</Alien mode>, the configuration file must be in the project
directory.

In L<Local mode>, it must be either in the C<src> directory or, as
a fallback, in the project directory (C<src> is searched first).

This is considered only before loading a configuration file, so any
setting inside the configuration file is ignored.

=item --local

=item -l

=item --no-local

=item DIBS_LOCAL

   $ dibs -l

Boolean option to select between L</Alien mode> and L</Local mode> (latter
when the value is true).

The C<DIBS_LOCAL> environment variable is tested as any Perl boolean, so
only the following values are I<false>: C<undef> (environment variable is
missing), empty string, number C<0>. Any other value is considered true.

This option is computed before loading the configuration file and cannot
be overridden even when missing from environment and/or command line.

=item --origin

=item -O

=item DIBS_ORIGIN

   $ dibs -O /path/to/origin.git

set a I<Git origin> from where C<src> will be cloned.

The clone is performed in the I<host context>, before the containers are
invoked. It is always done at the beginning and only once per invocation,
even in steps that technically do not rely on it (C<dibs> has no way to
tell).

The origin can be set inside the C<dibs.yml> file.

=item --project-dir

=item -p

=item DIBS_PROJECT_DIR

   $ dibs --project-dir directory

set the base directory of the project.

By default (i.e. L</--alien> is not set) it is the C<dibs> sub-directory
of the current directory (after L</--change-dir>).

In L</Alien mode> it defaults to the current directory (after
L</--change-dir>).

This option is computed before loading the configuration file and cannot
be overridden even when missing from environment and/or command line.

=back

I<Straight> command line arguments represent steps to be executed in the
specific run; they can also be set (comma or space-separated) via
environment variable C<DIBS_STEPS>. Example:

   $ dibs first,second third fourth,last

It defaults to whatever is found inside the C<dibs.yml> configuration
file. The example above leads to the following list of steps:

   - first
   - second
   - third
   - fourth
   - last

=head1 CONFIGURATION

Invocation of C<dibs> is explained in section L</OPTIONS>, which includes
command-line options and environment variables.

The core of the configuration for C<dibs> comes from the C<dibs.yml>
configuration file (but see L<--config-file>). This file has
a I<free-form>, in that only a few keys are meaningful to C<dibs> and the
rest is up to the writer (e.g. to concentrate other configurations that
can be of help for other tools).

Higher level keys are:

=over

=item C<defaults>

set defaults that can be reused around.

=item C<definitions>

define what each I<step> is supposed to do

=item C<name>

main name of the project (may be overridden in one or more steps)

=item C<steps>

list of steps to take. This can be overridden by command-line argument.

=back

=head2 C<defaults>

Associative array.

It is a best practice to put a sub-key C<variables> with the definition of
(YAML) variables that can be reused around as an array, like this:

   defaults:
      variables:
         - &base_image 'alpine:3.6'
         - &version 'DIBSPACK_SET_VERSION="0.001972"'
   ...
   definitions
      foo:
         from: *base_image

There is more to it anyway: if the item is a hash reference with a single
key C<function> whose associated value is an array, like in this example:

   defaults:
      variables:
         - &version_major           '0'
         - &version_minor           '1'
         - &version_patch           '1'
         - function: &version
            ['join', '.', *version_major, *version_minor, *version_patch]
         - function: &version_maj_min
            ['join', '.', *version_major, *version_minor]

then the first item in the array is taken as a I<function> name and the
rest as its arguments. Currently the following functions are supported:

=over

=item * C<join>

behaves like the Perl counterpart, taking the first parameter as separator
and joining the rest with it. In the example above, the first is expanded
as C<0.1.1> and the second one as C<0.1>.

=back


C<dibs> also recognizes sub-key C<dibspack>, allowing the definition of
several set of defaults for dibspacks. They can be used both I<the YAML
way> (note the anchor in the C<user> default dibspack):

    defaults:
       dibspack:
          user: &user
             type: src
             name: add user and enable for docker
             user: root
             path: dibspacks/user-docker.sh
    definitions:
       foo:
          dibspacks:
             - *user

or the C<dibs> way, that allows overriding parameters too:

    defaults:
       dibspack:
          basic:
             type:   git
             origin: https://github.com/polettix/dibspack-basic.git
             user:   user
    definitions:
       foo:
         ...
          dibspacks:
             - default: basic
               path: perl/build
               args: ['/app', 'ANOTHER=ENVIRONMENT_VARIABLE']

In this case, the key C<default> allows importing the whole block of the
associated entry in C<defaults> and then override values as needed.

=head2 C<definitions>

Associative array where the operations of each step can be defined. Keys
are names that can be used when defining the list of steps (see below),
values are associative arrayes themselves, where the following keys are
recognized:

=over

=item C<commit>

Boolean or associative array for committing a container as an image. Inthe
latter case, it supports the following keys:

=over

=item C<cmd>

String or list, has the same meaning as in the Dockerfile. Defaults to an
empty list.

=item C<entrypoint>

String or list, has the same meaning as in the Dockerfile. Defaults to
a list with strings C</bin/sh> and C<-l>, in order.

=item C<keep>

Boolean (either YAML or Perl), sets whether the resulting container of the
step should be kept as a Docker image or ditched away. Defaults to a true
value when absent; it is mostly useful to temporarily avoid generating an
image (e.g. to just check that the steps run fine), otherwise the whole
C<commit> section make little sense.

=item C<name>

String, overrides the global C<name> within the step and is used for
setting the name of the image. When absent, the C<name> at the YAML
highest level is taken.

=item C<tags>

List of strings, provides either tags or fully qualified names for images.

Any container is initially started from an image name that is generated
automatically, based on C<name> and a timestamp. This tag is eventually
dropped, unless the special tag C<*> (or its alias C<:default:>) are put
in the list. The automatically generated tag is also kept if there are no
tags in the list (or there is not C<tag> key at all).

=item C<user>

String, has the same meaning as in the Dockerfile.

=item C<workdir>

String, has the same meaning as in the Dockerfile.

=back


=item C<dibspacks>

Array of associative arrays, each specifying a dibspack to execute (in the
same order as they appear in the array. See below for details.

=item C<from>

String, has the same meaning as in the Dockerfile, i.e. specify a base
image where to start from.

=back

The C<dibspacks> array provides a list of dibspacks to execute, in the
same order as they appear. Each is an associative array itself, where the
following keys are recognized:

=over

=item C<args>

list of additional arguments passed to the program run in the dibspack
(the first three arguments are fixed and are always the C<src>, C<cache>
and C<env> directory paths inside the container).

=item C<default>

import key-value pairs from the relative entry in associative array inside
C<defaults.dibspacks>.

=item C<type>

The dibspack type, might be one of C<git>, C<immediate>, C<inside>,
C<project>, or C<src>. See relevant sections below for more details.

=item C<user>

the user for running the container, defaults to C<root>.

=back

=head3 Dibspack type C<git>

The dibspack can be retrieved from a git repository. The following
additional sub-keys are available:

=over

=item C<origin>

the URI of the git repository. It can also have a fragment part (after
a C<#> sign>) specyfing a ref to checkout.

=item C<path>

path to the dibspack program inside the repository. This allows having
multiple dibspack programs inside the same repository, like
L<https://github.com/polettix/dibspack-basic>.

=item C<ref>

the specific reference to checkout from the repository.

Note that the C<origin> might have a I<fragment> part (i.e. a dash C<#>
sign followed by the I<fragment string>) that is interepreted as a C<ref>
as well. In this case C<ref> cannot be present too.

=back

Example:

   ...
   - type:   git
     origin: https://github.com/polettix/dibspack-basic.git
     ref:    master
     path:   perl/build
     args:   ['/app', 'HEY=JOE']
     user:   user

=head3 Dibspack type C<immediate>

This dibspack is a program whose code is provided in the YAML definition
itself, inside key C<program>. Example:

   ...
   - type: immediate
     program: |
         #!/bin/sh
         printf '%s\n' 'Hello, world!'

=head3 Dibspack type C<inside>

This dibspack allows calling a program that is I<already> inside the
container. This might probably not be a good idea, but who knows.

Accepts an additional key C<path> with the absolute path to the program
inside the container.

=head3 Dibspack type C<project>

This dibspack type allows calling a dibspack inside the C<dibspacks>
directory inside the project directory.

Accepts an additional key C<path> with a path that is always interpreted
as relative to that directory.

=head3 Dibspack type C<src>

This dibspack type allows calling a dibspack inside the C<src> directory.

Accepts an additional key C<path> with a path that is always interpreted
as relative to that directory.


=head2 C<name>

String, name of the project. This is also what saved Docker images are
named by default, although this can be overridden inside each step.

=head2 C<steps>

This is just a list of strings. Each must be the identifier of a valid
definition inside L<< /C<definitions> >>. Example:

   definitions:
      foo:
         ...
      bar:
         ...
      baz:
         ...
   steps:
      - bar
      - foo
      - baz
      - foo


=head1 DIAGNOSTICS

Whatever fails will complain quite loudly.


=head1 DEPENDENCIES

See C<cpanfile>.

C<dibs> is also a C<dibs> project itself, compilable in L</Local mode>;
chances are that the C<polettix/dibs> Docker image available at
L<https://hub.docker.com/r/polettix/dibs/> suffices for just using it.

=head1 BUGS AND LIMITATIONS

Please report any bugs or feature requests through the repository at
L<https://github.com/polettix/dibs>.

Reading configurations from the C<dibs.yml> file is somehow liberal,
allowing the presence of keys that are not required or used by C<dibs>.
This might be regarded as a limitation because it makes C<dibs> prone to
typos.


=head1 AUTHOR

Flavio Poletti C<polettix@cpan.org>


=head1 LICENCE AND COPYRIGHT

Copyright (c) 2018, Flavio Poletti C<polettix@cpan.org>.

This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0.

This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=cut
